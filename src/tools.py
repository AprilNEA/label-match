import os
import asyncio
import aiofiles
import cv2

from os import PathLike
from typing import Union, List
from src import utils

IGNORE_FILE = [".DS_Store", "classes.txt"]


def draw(img, x, y):
    for i in range(4):
        if i < 4:
            cv2.circle(img, (int(x[i]), int(y[i])), 3, (255, 255, 0), -1)
        else:
            cv2.circle(img, (int(x[i]), int(y[i])), 3, (0, 0, 255), -1)
    return img


async def read_classes(class_data: Union[str, PathLike, bytes]) -> List:
    """
    Read label lists from file
    :param class_data:
    :return: a list of labels
    """
    label_list: List = []
    if isinstance(class_data, str):
        try:
            async with aiofiles.open(class_data) as f:
                for line in await f.readlines():
                    label_list.append(*line.split())
        except OSError as e:
            print("unable to open classes.txt")
            raise e
    return label_list


async def write_classes(class_data: Union[str, PathLike, bytes], datas: List):
    """
    write the file of label date of the image
    :param class_data:
    :param datas:
    :return:
    """
    num = -1
    print(datas)
    out = ""
    for data in datas:
        num += 1
        out += f"{data[0]} {data[1]} {data[2]} {data[3]} {data[4]}\n"

    if isinstance(class_data, str):
        try:
            async with aiofiles.open(class_data, "a+") as f:  # cover write
                print(out)
                await f.write(out)
        except OSError as e:
            print("unable to open classes.txt")
            raise e
    return True


async def labelimg_order_correction(labelimg_path, classes_now, classes_right):
    """
    Unify the labelimg data generated by different classes.txt
    :param labelimg_path:
    :param classes_now:
    :param classes_right: Select unified classes.txt
    :return:
    """
    label_now: List = await read_classes(classes_now)
    label_right: List = await read_classes(classes_right)
    list_labelimg = os.walk(labelimg_path)
    for path, dir_list, file_list in list_labelimg:
        for file_name in file_list:
            if file_name not in IGNORE_FILE:
                try:
                    datas = []
                    with open(os.path.join(path, file_name)) as f:
                        for line in f.readlines():
                            datas.append(line.split())
                except FileNotFoundError as e:
                    print("The corresponding labelimg data is missing")
                    raise e
                finally:
                    num = 0
                    for data in datas:
                        sn = int(data[0])
                        try:
                            label_name_now = label_now[sn]
                        except IndexError:
                            print(f"{file_name}Wrong")
                            continue
                        right_sn = label_right.index(label_name_now)
                        datas[num][0] = right_sn
                        print(f"{file_name}原标签序号{sn}为标签{label_name_now},正确标签序号{right_sn}为标签{label_right[right_sn]}")
                        num += 1
                    await write_classes(f"200/out/{file_name}", datas)


async def check_image(image_path, final_path):
    classes_list = ["B1", "B2", "B3", "B4", "B5", "BO", "BS", "R1", "R2", "R3", "R4", "R5", "RO", "RS"]

    for path, dir_list, file_list in os.walk(image_path):
        for file_name in file_list:
            if "png" in file_name:
                img = cv2.imread(image_path + file_name)
                height, width, _ = img.shape
                sn = file_name.split('.')[0]
                datas = []
                try:
                    async with aiofiles.open(f"{final_path}/{sn}.txt") as f:
                        for line in await f.readlines():
                            file_data = line.split(' ')
                            for sn1, i in enumerate(file_data):
                                if "\n" in i:
                                    file_data[sn1] = i.replace("\n", "")
                            datas.append(file_data)
                except FileNotFoundError:
                    print(f"There is no data in {sn}")
                print(f"The label of {sn} image: ", end="")
                for data in datas:
                    img_data = utils.xywh2four_coordinate(data, width, height)
                    me_data = utils.normalized8point2coordinate4(data[5:13], width, height)
                    cv2.rectangle(img, (int(img_data[0][0]), int(img_data[0][1])),
                                  (int(img_data[2][0]), int(img_data[2][1])),
                                  (255, 255, 0))
                    for i in range(4):
                        cv2.circle(img, (int(me_data[i][0]), int(me_data[i][1])), 3, (0, 0, 255), -1)
                    print(f"{classes_list[int(data[0])]} ", end="")
                cv2.imshow(file_name, img)
                cv2.waitKey(0)
                cv2.destroyWindow(file_name)
                print("\n", end="")


if __name__ == '__main__':
    pass
#     asyncio.run(
#         labelimg_order_correction("200/labelimg/", "200/labelimg/classes.txt", "200/classes.txt")
#     )
# asyncio.run(
#     check_image("200/imgs/", "label/final")
# )
